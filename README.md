# myexample -- .NET and Linux containers example
### Simple C# .NET web service example with multiple build/containerization approaches


### This example follows more expanded explanations collated from the following sources.
*NOTE: Given .NET's cross platform support and common SDK and runtime, in most cases these source guides are OS agnostic, or can be easily applied across Mac, Linux, and Windows inner loop development environments.*

Dockerfile/Containerfile Approach
- .NET on Red Hat Enterprise Linux https://developers.redhat.com/cheat-sheets/net-core-red-hat-enterprise-linux
- Getting started with .NET on RHEL 9 https://docs.redhat.com/en/documentation/net/8.0/html-single/getting_started_with_.net_on_rhel_9/index
- How to build multi-architecture container images https://developers.redhat.com/articles/2023/11/03/how-build-multi-architecture-container-images
- Multi-stage builds https://docs.docker.com/build/building/multi-stage/
- Build lean container images with UBI and Podman https://developers.redhat.com/articles/2023/05/17/build-lean-nodejs-container-images-ubi-and-podman

.NET SDK CLI **dotnet publish** command Approach
- Customize the build by folder https://learn.microsoft.com/en-us/visualstudio/msbuild/customize-by-directory?view=vs-2022 
- Containerize a .NET app with dotnet publish https://learn.microsoft.com/en-us/dotnet/core/docker/publish-as-container?pivots=dotnet-8-0
- Introduction to .NET and Docker https://learn.microsoft.com/en-us/dotnet/core/docker/introduction



## Overview
This simple web service "myexample" is mostly the default code generated by using the command  
**dotnet new webapi**  
This creates a simple REST service that returns a default weather forecast  

The project has then been modified to focus on building containers.  

Two different containerization approaches are added in as examples of how a developer can build a container in their local development environment.
- Dockerfile/Containerfile Approach
- .NET SDK CLI **dotnet publish** command Approach  

Neither of these example approaches offered here are meant to be exhaustive of all the permuations and options available.  They are meant as a quickstart for .NET programmers to get a grasp on how they can build containers in their current desktop/laptop environment.

## Requirements
- .NET 8.0 SDK
- podman or docker installed

## Run / Test the service locally (not containerized)
- Ensure you are in the myexample directory
- Run the webservice ```dotnet run```
- The terminal window should show something like  
Now listening on: http<no link>://localhost:PORT
- From either a browser or a curl command, or some other approach run  
http<no link>://localhost:PORT/weatherforecast  
You should see the default answer.  If you are interested in how the code works, review Program.cs for more details.
- Make sure you kill the process when you are done.

### Building the Container Image
#### Dockerfile / Containerfile Approach
Both a Dockerfile and a Containerfile have been added to the project.  They basically represent the same instructions and syntax.  Containerfiles are assoicated with podman.  Dockerfiles are associated with docker, but podman can also run them.  Basically the podman approach focuses on building and running oci (open container initiative) compliant images.  Podman, unlike docker, does not run as a daemon process, among other things.  Further delineation is outside the scope of this example.  

NOTE: Going into detail on how dockerfiles work and the syntax is beyond this example.  
- Basically the Dockerfile and Containerfile in this example both use multi-stage builds to create leaner, faster, and more efficient image containers.  Links above go into detail on this approach.
- You will also notice that the base and builder images used are Red Hat Universal Base Images (UBIs).  Your organization may have their own builds of these images, or use others, such as ones from Microsoft.  Red Hat UBI's provide airtight security and are optimized on RHEL base images for high performance and efficiency.
- Also towards the end of each Dockerfile and Containerfile commands are included to ensure the container image does not run in ROOT user mode.  This is especially important when running in a highly secure application platform like Red Hat OpenShift.

*Building and Running*   
To locally build a container image try the following (you may need to adjust syntax to support your particular environment). -- Both podman and docker approaches are offered --
- the following assumes you are in the **myexample** base directory  
- To build the image with **podman** try: ```podman build -f Containerfile -t myexample .```
- *OR* To build the image with **docker** try: ```docker build -f Dockerfile -t myexample .```
- To run the container with **podman** : ```podman run -p 8080:8080 myexample```  
- *OR* To run the container with **docker** : ```docker run -p 8080:8080 myexample```
- You can see the results by running ```localhost:8080/weatherforecast``` in your browser or as a curl command.


#### .NET SDK CLI **dotnet publish** command Approach 
This is a newer approach that is provided directly from the .NET 8.0 SDK. .NET developers are encouraged to review the document links above for a full understanding.  Basically the **dotnet publish** CLI command has been expanded to invoke an MSBuild that creates a docker compliant container image (it can also use podman for that creation).  

In order to kick off an image build the documentation describes how someone can pass in parameters and settings at the commandline.  One can also pass in property files with project level settings, just as can normally be done with a .NET C# project.  In .NET there is a hierarchy for where and how property files can be located and called.  The above links go into this in detail.

For purposes of this example a *Directory.Build.props* file was created in the base directory and in it a source builder image and supported runtime container OS's were set. Other settings are possible such as image name and tag.

To build this example using this approach run:  
```dotnet publish myexample.csproj -t:PublishContainer```
This will create an image with the name being the project name.  As mentioned, the .NET documentation offers many ways to adjust settings and paramaters.

You can then run the container similiar to the docker approach above, but replacing the -t parameter with the project name and tag  i.e.  *-t myexample:1.1* .

### Next Steps
This example has focused on a couple of approaches to locally build .NET containerized services on a local developer environment.  A logical follow on is to deploy .NET applications to an Application Platform like Red Hat OpenShift, which follows a Kubernetes approach to managing containers.  There are several approaches to do this, and can be covered in other example projects.








